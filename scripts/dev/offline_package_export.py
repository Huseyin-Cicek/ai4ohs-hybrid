"""Utility for preparing offline wheel artifacts and checksums.

Run on an internet-connected workstation to download all required wheels
into ``packages/`` and generate a ``checksums.sha256`` manifest.
"""

from __future__ import annotations

import argparse
import hashlib
import subprocess
import sys
from pathlib import Path
from typing import Iterable

REPO_ROOT = Path(__file__).resolve().parent.parent.parent
PACKAGE_DIR = REPO_ROOT / "packages"
DEFAULT_REQUIREMENTS = ["requirements.lock", "requirements.txt"]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Prepare offline wheel bundle")
    parser.add_argument(
        "--requirements",
        "-r",
        nargs="*",
        help="Requirement files to mirror (default: requirements.lock then requirements.txt)",
    )
    parser.add_argument(
        "--extra-index-url",
        nargs="*",
        default=[],
        help="Additional package indexes passed to pip download",
    )
    parser.add_argument(
        "--clear",
        action="store_true",
        help="Remove existing wheel artifacts before downloading",
    )
    parser.add_argument(
        "--pip-arg",
        dest="pip_args",
        nargs="*",
        default=[],
        help="Extra arguments forwarded to pip download",
    )
    return parser.parse_args()


def resolve_requirements(custom: Iterable[str] | None) -> list[Path]:
    candidates = list(custom) if custom else DEFAULT_REQUIREMENTS
    resolved: list[Path] = []
    for rel_path in candidates:
        req_path = (REPO_ROOT / rel_path).resolve()
        if req_path.exists():
            resolved.append(req_path)
    if not resolved:
        raise FileNotFoundError(
            "No requirement files found. Expected one of: "
            + ", ".join(str(REPO_ROOT / p) for p in candidates)
        )
    return resolved


def ensure_package_dir(clear: bool) -> None:
    PACKAGE_DIR.mkdir(parents=True, exist_ok=True)
    if clear:
        for wheel in PACKAGE_DIR.glob("*.whl"):
            wheel.unlink()


def run_pip_download(
    requirements: list[Path], extra_indexes: list[str], pip_args: list[str]
) -> None:
    cmd = [sys.executable, "-m", "pip", "download", "--dest", str(PACKAGE_DIR)]
    for req in requirements:
        cmd.extend(["-r", str(req)])
    for url in extra_indexes:
        cmd.extend(["--extra-index-url", url])
    if pip_args:
        cmd.extend(pip_args)

    print("[*] Running:", " ".join(cmd))
    subprocess.run(cmd, check=True)


def compute_sha256(path: Path) -> str:
    hasher = hashlib.sha256()
    with path.open("rb") as handle:
        for chunk in iter(lambda: handle.read(1024 * 1024), b""):
            hasher.update(chunk)
    return hasher.hexdigest()


def write_checksums() -> None:
    wheels = sorted(PACKAGE_DIR.glob("*.whl"))
    output = PACKAGE_DIR / "checksums.sha256"

    lines = ["# Generated by scripts/dev/offline_package_export.py"]
    lines.append("# Format: <sha256>  <filename>")

    for wheel in wheels:
        digest = compute_sha256(wheel)
        lines.append(f"{digest}  {wheel.name}")

    output.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"[*] Wrote {len(wheels)} checksum entries to {output}")


def main() -> None:
    args = parse_args()
    requirements = resolve_requirements(args.requirements)
    ensure_package_dir(args.clear)
    run_pip_download(requirements, args.extra_index_url, args.pip_args)
    write_checksums()
    print("[âœ“] Offline package bundle ready in", PACKAGE_DIR)


if __name__ == "__main__":
    main()
