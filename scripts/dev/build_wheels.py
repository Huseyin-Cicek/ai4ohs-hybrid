"""Utility for generating a hashed requirements lock file and wheel cache.

This script reads the pinned entries in ``requirements.txt``, downloads the
corresponding wheels (if necessary) into a local wheel cache directory, and
then emits a ``requirements.lock`` file with SHA-256 hashes for each entry.

Typical usage::

    python scripts/dev/build_wheels.py

Run with ``--help`` to see additional options such as custom wheel or lock
output directories. The script expects every requirement to be pinned with a
single ``==`` specifier; it will abort if floating requirements are detected.
"""

from __future__ import annotations

import argparse
import hashlib
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Sequence

from packaging.requirements import Requirement
from packaging.utils import canonicalize_name


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build wheel cache and hashed lock file")
    parser.add_argument(
        "--requirements",
        type=Path,
        default=Path("requirements.txt"),
        help="Path to the pinned requirements file",
    )
    parser.add_argument(
        "--lock-file",
        type=Path,
        default=Path("requirements.lock"),
        help="Destination for the hashed requirements lock file",
    )
    parser.add_argument(
        "--wheel-dir",
        type=Path,
        default=Path(".cache") / "wheels",
        help="Directory where downloaded wheels will be stored",
    )
    parser.add_argument(
        "--pip-executable",
        default=sys.executable,
        help="Python executable to use for invoking pip",
    )
    parser.add_argument(
        "--extra-pip-args",
        nargs="*",
        default=(),
        metavar="ARG",
        help="Additional arguments forwarded to 'pip download'",
    )
    parser.add_argument(
        "--upgrade",
        action="store_true",
        help="Force re-download of wheels even if cached ones exist",
    )
    return parser.parse_args()


@dataclass(frozen=True)
class ParsedRequirement:
    raw_line: str
    requirement: Requirement

    @property
    def name(self) -> str:
        return canonicalize_name(self.requirement.name)

    @property
    def pinned_version(self) -> str:
        specifiers = list(self.requirement.specifier)
        if len(specifiers) != 1:
            raise ValueError(f"Requirement '{self.raw_line}' must contain exactly one specifier")
        spec = specifiers[0]
        if spec.operator != "==":
            raise ValueError(f"Requirement '{self.raw_line}' must be pinned with '=='")
        return spec.version

    def as_line(self) -> str:
        return f"{self.requirement.name}=={self.pinned_version}"


def load_requirements(path: Path) -> List[ParsedRequirement]:
    if not path.exists():
        raise FileNotFoundError(f"Requirements file not found: {path}")

    parsed: List[ParsedRequirement] = []
    for lineno, raw_line in enumerate(path.read_text().splitlines(), start=1):
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        try:
            requirement = Requirement(line)
        except Exception as exc:  # pragma: no cover - packaging gives informative message
            raise ValueError(f"Invalid requirement on line {lineno}: {line}\n{exc}") from exc
        parsed.append(ParsedRequirement(raw_line=line, requirement=requirement))

    if not parsed:
        raise ValueError(f"No requirements found in {path}")

    return parsed


def find_existing_wheels(name: str, version: str, wheel_dir: Path) -> List[Path]:
    canonical = name.replace("-", "_")
    normalized_version = version.replace("-", "_")
    pattern = f"{canonical}-{normalized_version}*.whl"
    return sorted(wheel_dir.glob(pattern))


def download_wheels(
    requirement_line: str,
    wheel_dir: Path,
    pip_executable: str,
    extra_args: Sequence[str],
) -> None:
    wheel_dir.mkdir(parents=True, exist_ok=True)
    cmd: List[str] = [pip_executable, "-m", "pip", "download", "--only-binary=:all:", "--no-deps"]
    if extra_args:
        cmd.extend(extra_args)
    cmd.extend(["--dest", str(wheel_dir), requirement_line])
    subprocess.run(cmd, check=True)


def compute_sha256(file_path: Path) -> str:
    digest = hashlib.sha256()
    with file_path.open("rb") as handle:
        for chunk in iter(lambda: handle.read(1024 * 1024), b""):
            digest.update(chunk)
    return digest.hexdigest()


def write_lock_file(
    lock_path: Path, requirements: Iterable[ParsedRequirement], wheel_dir: Path
) -> None:
    lines: List[str] = [
        "# This file is auto-generated by scripts/dev/build_wheels.py",
        "# Do not edit manually.",
    ]

    for parsed in requirements:
        wheel_files = find_existing_wheels(parsed.name, parsed.pinned_version, wheel_dir)
        if not wheel_files:
            raise FileNotFoundError(
                f"No wheel found for {parsed.as_line()} in {wheel_dir}. Run the script to download wheels."
            )

        hashes = [f"--hash=sha256:{compute_sha256(wheel)}" for wheel in wheel_files]
        hash_segment = " ".join(sorted(hashes))
        lines.append(f"{parsed.as_line()} {hash_segment}" if hash_segment else parsed.as_line())

    lock_path.parent.mkdir(parents=True, exist_ok=True)
    lock_path.write_text("\n".join(lines) + "\n")


def main() -> None:
    args = parse_args()

    requirements = load_requirements(args.requirements)
    wheel_dir = args.wheel_dir

    for parsed in requirements:
        wheel_files = find_existing_wheels(parsed.name, parsed.pinned_version, wheel_dir)
        if args.upgrade or not wheel_files:
            download_wheels(parsed.as_line(), wheel_dir, args.pip_executable, args.extra_pip_args)

    write_lock_file(args.lock_file, requirements, wheel_dir)
    print(f"Lock file written to {args.lock_file}")
    print(f"Wheels available in {wheel_dir}")


if __name__ == "__main__":
    main()
